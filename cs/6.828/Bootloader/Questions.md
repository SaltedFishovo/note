#### 为什么进入保护模式后，还可以顺序执行指令，而没有因为CS高速缓存器扰乱执行

#### 为什么Boot.s汇编不需要指定.text .end等..



#### 对程序中虚拟地址、重定位入口填入的绝对地址的猜想：

对于一个完全链接的可执行目标文件来说，程序每一条指令、每一个全局符号、各个段等的加载后的虚拟地址，在链接时就已经被指定好了。即程序的虚拟地址空间已经被分配好了。

假设有一完全链接的程序，加载后程序开始于虚拟内存中0x100h，那么程序中的**绝对引用都会以0x100h来重定位。**

有一个全局变量 *a* 在文件中的偏移为 *0xd0h* ，同时在代码中对这个变量有取地址操作：

```C
gobal int a;
int * b = &a;
```

因为 *a* 在文件中的位置是 *0xd0h*，当这个程序被加载后，其整体就会被加载到虚拟内存位置 *0x100h* 处，所以  *a* 就会被加载到虚拟内存位置 *0xdh+0x100h* 处，在汇编代码中就会生成一个关于 *a* 的绝对引用：

```assembly
mov $1d0h,%eax; #the address of <a> will be in %eax.
```

有两个办法可以修改程序在虚拟内存中的起始位置：

- 链接时指定参数：*-Ttext init_addr*
- 使用链接脚本： *. = init_addr* 

这个地址会体现在Program header中的 *vma* 成员。



#### 链接时，何时生成相对引用，何时生成绝对引用

- 直接调用一个函数，直接读写一个在内存中的变量会生成相对引用。
- 对符号进行取地址操作等间接操作时，会生成绝对引用，无论是赋值，取值。
  - 引用函数的**地址**
  - 取变量（数组、结构体等）地址为指针赋值
  - 对一个指针进行间接操作（读、写） **<-**     Why?