参考资料IA32-3A Chapter4.11

#### 1.X86架构知识

X86使用两个bit来描述一个页面的访问情况：

- Restricting Addressable Domain:User/Supervisor bit；
  - U/S = 1 : User Mode and Supervisor Mode 可访问
  - U/S = 0 : 仅 Supervisor Mode 可访问
- Page Type: R/W flag；
  - R/W = 1 : R/W
  - R/W = 0 : R only

错误的读写一个虚拟地址可能造成页故障，然后被分发到缺页中断处理程序中，此处仅说明User Mode下会产生页故障情况：

- 读写一个Supervisor Mode下才能读写的页
- 写一个Read Only（R/W = 0）的页



#### 2.JOS判断一个页面是否为写时复制页的逻辑

- 要想在用户模式下写入一个页面时产生页故障，要么将这个设置为Supervisor的，要么设为只读的。此时需求是实现写时复制，自然是设置为只读更合适。
- 进程地址空间中本身就有只读的页面（代码段等），此时通过只需要使用AVLIBLE字段中某个固定的位，标识出这是一个写时复制的页面即可，在JOS中定义为PTE_COW常量。

当执行在JOS中的进程产生上述读写情况时，处理器控制权最终会转移到用户级页故障处理程序，此时只需要判断进程要读写页面的页表条目中 PTE_COW && (! PTE_W) 是否为真，如果是真则代表这是一个写时复制。



#### 3.FORK工作流程

1. 设置upcall以及pgfault hanlder
2. 使用exo_fork在进程数组中分配一个新的进程
3. 复制用户地址空间的映射：
   - 如果页面是可写或COW的则映射为COW
     - 当映射
     - 已经是写时复制的页面，也要重新在父进程的地址空间再次映射为写时复制的
   - 其他情况则不变flag不变
4. 为子进程分配一个新的异常栈物理页面，并为子进程设置pgfault hanlder
5. 将子进程状态设置为可运行的

##### 1） 为什么先映射子进程的页面为COW 再映射父进程的页面为COW

父进程调用syscall将某虚拟页被标识为只读、写时复制

假设此时父进程向该某虚拟页中写入数据，此时会执行一个页故障处理程序 ：

- 将该虚拟页的物理页面数据复制到一个新的页面中，并将这个新的物理页面以可读写的方式映射到父进程虚拟地址空间相应位置
- 之前的虚拟页所映射的物理页呢？

子进程syscall将这个新的物理页面映射到其虚拟地址空间 **（出错了，因为子进程的所有状态要和执行call fork指令时父进程的状态一致）**

正常情况下不会有问题，但是当循环到向子进程映射用户栈页面时，必然会出现上述错误：第一次调用syscall为父进程自己将栈物理页面映射为只读写时复制的。第二次调用syscall为子进程映射栈页面时，在父进程中，call指令会将返回地址压栈，此时必然会分配为父进程分配一个新的、可读写非写时复制的页面作为栈。这样就违背了写时复制的原则。



##### 2） 为什么已经是写时复制了，还需要重新映射为写时复制的

先调用syscall在子进程中映射这个写时复制的页面，假设正在映射的页面是栈的页面，此时父进程调用syscall会向栈中写入数据，这样会触发pgfault处理程序，会将栈的物理页面复制一份，再映射到父进程相应的区域。

为了保证在fork结束后，每一个R/W或COW的页面都为COW，所以需要重新将栈的物理页面以COW的方式映射到父进程中。



##### 3）异常栈

#### 4.缺页处理程序

- 在异常栈中判断造成故障的操作：
  - 如果操作是写一个COW页面，则执行继续执行
  - 其他操作则panic
- 在一个临时的位置上分配一个页面，将造成故障的页面的数据复制进去，然后在以R/W的权限将这个物理页面映射到相应的位置，并取消这个临时位置的映射。