#### *pte_t \*pgdir_walk(pde_t   \*pgdir,  const void  \*va, int  create)* 

返回虚拟地址va所在的虚拟页面的页表条目的地址

页表相关知识：根据该函数调用时的上下文，页目录pgdir一定是存在于物理内存中的。在x86-32中，页目录共有占虚拟地址最高10位，MMU用这10位作为找到页目录的索引，故一个页目录有1024个条目，而据规定每个页目录条目4B，所以页目录刚好占了一个页面。

页目录条目存储了相应的二级页表所在的物理页面的物理页号。某个页目录条目可能是无效的，此时P位为0，这说明该片区域一个虚拟页面也没有被映射

二级页表的索引位同样为10位，如果页目录条目有效，MMU根据CR3和虚拟地址中的页目录条目索引位找到一个相应的页目录条目后，在这个物理页中，以二级页表索引位作为一个索引，找到其二级页表条目。

某个虚拟页面可能未被映射，此时该页面的页表条目P位为0。如果P位为1，则说明va所在的虚拟页面被映射到了这个页表条目存储的物理页号的页面。

pgdir_walk()的功能：

- 页目录条目有效
  - 返回va的页表条目的地址，即便va所在的虚拟页面未被映射
- 页目录条目无效
  - create = 1
    - 分配一个物理页，填入该页目录条目，返回va的页表条目的地址
    - 分配物理页失败，返回NULL
  - create = 0
    - 返回NULL

我们可以用该函数：查询页表、映射页面、判断页面是否被映射..

#### *struct PageInfo \*page_lookup(pde_t \*pgdir, void \*va, pte_t \*\*pte_store)* 查询给定虚拟页的物理页结构体或页表信息
返回被映射到虚拟页面va的物理页，如果pte_store不为空，则将该页表条目的地址存储至pte_store中。



#### *int page_insert(pde_t \*pgdir, struct PageInfo \*pp, void \*va, int perm)* 将物理页pp映射到虚拟页va，权限位perm

该虚拟页已经映射了怎么办？映射的是同一个物理页怎么办？