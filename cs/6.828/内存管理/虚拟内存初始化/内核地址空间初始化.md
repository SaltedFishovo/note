### 概述

### 虚拟内存简述

x86架构中通过分段和分页机制实现虚拟内存系统，其中的分段机制是由于历史原因，需要兼容历代x86处理器，而不得不保留、使用的机制，所以本文中将简述x86的分页机制。

分页硬件主要的功能就是**通过查询页表，虚拟地址翻译成物理地址。**在IA32架构中，通常情况下采用二级页表的策略来节约空间，一个32位虚拟地址可分为三部分。如图所示，其中 *bit22-bit32* 为页目录索引，  *bit12-bit21* 为页表索引， *bit0-bit11* 为页内偏移。页目录基址寄存器 *pdtr* 存储了页目录在物理内存的地址。



页表实际上就是一个页表条目的数组，其中每一个条目中存着一个物理页号，和几个权限位，页目录条目和页表条目具有完全相同的结构，如下图所示，*bit11* 至 *bit31* 存储了一个物理页号，bit：



处理器进行一次地址地址翻译大致过程如下：

- 通过页目录基址寄存器的值加上页目录索引，然后得到该虚拟地址



所谓的建立虚拟地址空间，实际上就是创建一个页表，然后通过页表映射具有相应数据的物理页。在JOS在启动过程中，初始化完物理内存后，就开始映射内核地址空间，即，对 *kern_pgdir* 所指向的页目录进行的设置。此时主要映射了四个部分到内核的虚拟地址空间，如图所示：

- 将虚拟地址空间的0xEF000000 - 0xEF040000 映射到物理内存的*Struct pages* 结构体数组区域。

- 将虚拟地址空间0xEEC00000 - 0xEF00000 映射到物理内存的 *Struct Env* 结构体数组的数组区域。

- 将 定义在 *entry.S* 中的 *bootstack* 映射至0xF0000000  - KSTAKSIZE，作为内核栈。
- 将虚拟地址空间的0xF000000 - 0 x FFFFFFFF 区域映射至物理内存开始的256MB。



#### 实现

JOS通过一个函数 *boot_map_region()* 来实现对虚拟内存的映射，如下代码所示，该函数共有五个参数，*pgdir* 指定了对哪个页表进行映射；*va* 指定了开始的虚拟内存地址，*size* 是映射区域的长度，以字节为单位；*pa* 是要映射到的物理内存区域开始的地址；*perm* 是该区域中每一个页面的权限。

该函数将一段连续的虚拟内存区域 *[va，va+len)* 映射到一段连续的物理内存区域 *[pa，pa+len)*。

```C
void
boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
{
        pte_t * p_pte;
        size_t map_pgnum;
        uint32_t create = 1;

        map_pgnum = size / PGSIZE;
        for( size_t i = 1; i <= map_pgnum; i++, va += PGSIZE, pa += PGSIZE) {
                p_pte = pgdir_walk(pgdir, (const void *)va, create);
                if(!p_pte) break;
                *p_pte = pa | perm | PTE_P;
        }
}
```

首先使用映射区域的长度 size 除以 PGSIZE 计算出需映射的页数，该值存储于变量 *map_pgnum* 中，所以在函数中进行一个次数为 *map_pgnum* 的循环，每次循环通过 *pgdir_walk()* 函数获取 *pgdir* 指向的页目录中虚拟地址 *va* 的页表条目的地址，然后再将相应的物理页 *pa* 和一些权限位写入到这个页表条目中，最后 *va* 、*pa*进行增加，使之指向下一页。



