#### 快速计算二进制移位：以右移为例

1. 右移动n位，左边多出n个0。

2. 右移动n位，右边少了n个0。

3. 右移n位，假设从左到右数第一个1位右边的一位被称作“第一位”，那么从左到右数第一个1位就被移动到了第n位上。 

   ##### 例：

1  0  0  0  0 B >> 3 -> 00010 即右移3位，假设从左到右数第一个1位右边的一位被称作“第一位”，那么从左到右数第一个1位就被移动到了第3位上。

11100000  >> 2 :00111000

00111000 >> 2 : 00001110

#### 计算某一页的地址范围

512页，即第513页的虚拟页号为：

第1页 -> 0 ~ 4095

第2页 -> 4096~2 * 4096 - 1

第3页 -> 2 * 4096 ~ 3 * 4096-1

第513页 -> 512 * 4096 ~ 513 * 4096 -1 =20 0000H ~ 20 0FFFH



000H~FFFH -> 0Bytes~4095Bytes 1000H = 4096Byte

#### 十六进制0的个数和2的幂的关系

10H = 2^4

100H = 10H * 10H = 2^4 * 2^4 =2^8

1000H = 100H * 2^4 = 3*(2^4)

10...00H (n个0) = n * (2^4) = 2^(4n)



#### 栈的加法与减法模型

假设有一段内存为0~10内存单元， 每个程序的stack的大小为3bytes，stack向下增长。

**栈顶减法模型：**（开辟新的栈空间）

程序A的stack的栈顶的最小值p->kernel为5，则sp=5+3=8，7是A的栈底。

此时如果要放入一个short int，栈顶=sp-sizeof(short int)

即，低地址增长栈模型下，栈顶指向已被使用的、最低地址的内存单元，此时一个n字节的数据入栈，为了开辟空间，需要有栈顶地址-n。

**栈顶加法模型:**（取栈上元素）

程序A的stack最小单元，即栈顶的限度p->kernel为5，此时栈顶sp=5，也就是说栈满了。此时程序A栈的内存单元为5，6，7。 此时执行*（short int *）6，则会取出6 7两个内存单元的数据作为一个短整型。